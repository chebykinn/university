---
number: 1
type: Курсовая работа
subject: Методы цифровой обработки сигналов
author:
	- Чебыкин И. Б.
inspector:
	- Тропченко А. А.
name: Вариант 12
header-append:
	- \usepackage{verbatim}
	- \usepackage{tikz}
	- \usetikzlibrary{shapes,arrows}
---

# Задание

Имеется специализированный процессор для линейной фильтрации сигналов. На вход
ему поступают дискретные сигналы в формате целых чисел разрядности $n_1$. При
фильтрации применяются весовые коэффициенты, имеющие разрядность $n_2$. Все
промежуточные и конечные результаты имеют разрядность $n_3$.

Требуется:

1. Написать программу на любом языке программирования, которая
   реализует алгоритм линейной фильтрации, используя внутри числа
   с плавающей точкой;
2. Написать программу, которая реализует тот же алгоритм, но
   использует целые числа разрядностей $n_i$;
   Определить зависимости:
    1. Среднеквадратической погрешности от длины
      обрабатываемого вектора данных и/или длины ядра
      преобразования;
    2. Точности от способа формирования малоразрядного
      результата: с отсечением младших разрядов, с
      отсечением и увеличением младшего разряда на
      единицу, с округлением;
    3. Среднеквадратического отклонения от длины
      обрабатываемого вектора для всех трёх способов;
    4. Среднеквадратического отклонения от длины
      обрабатываемого вектора при округлении
      результата с изменением:
      - $n_1$ на 2 и 4 бита;
      - $n_2$ на 2 и 4 бита.

## Вариант

Вычисление апериодической свёртки при $M = 5, N = [10; 40], n_1 = 8, n_2
= 4, n_3 = 12$.

# Математические соотношения

Свёртка --- алгоритм, при котором на вход поступают две последовательности ---
$a(n)$, $b(m)$, где $n \in [0; N), m \in [0; M)$ --- и на выходе имеется новая
последовательность, представляющая собой произведение элементов $a$ и $b$
такое, что элементы $a$ берутся по возрастающему индексу, а $b$ --- по
убывающему.

Апериодическая свёртка --- частный случай свёртки, при котором входные
последовательности не зацикливаются, а дополняются нулями.

Определим $A(n), n \in \mathbb{Z}$ как функцию, которая на $n \in [0; N)$ имеет
те же значения, что и $a(n)$, а на остальной области определения --- $0$.
Аналогично определим $B(m)$ как расширение $b(m)$.

Тогда элемент выходной последовательности высчитывается следующим образом:

$$c(k) = \sum\limits_{i = 0}^k A(i) \cdot B(k-i), k \in [0; N + M - 2]$$

## Блок-схема

\begin{figure}[h]
        \centering
        \tikzstyle{decision} = [draw, diamond, aspect=2]
        \tikzstyle{block} = [draw, rectangle]
        \begin{tikzpicture}[node distance=4em, auto]
                \node[draw, ellipse] (begin) {Вход};
                \node[block, below of=begin] (init0) {$i \leftarrow 0$};
                \node[decision, below of=init0, node distance=6em] (loop0)
                        {$i < N + M - 1$};
                \node[block, above of=loop0, xshift=12em] (inc0)
                        {$i \leftarrow i + 1$};
                \node[block, below of=loop0, xshift=6em]
                        (init11) {$j \leftarrow 0$};
                \node[block, below of=init11] (init12)
                        {$c_i \leftarrow 0$};
                \node[decision, below of=init12] (loop1)
                        {$j \le i$};
                \node[decision, below of=loop1, node distance=6em] (doadd)
                        {$i < N \land k - i < M$};
                \node[block, below of=doadd, xshift=8em] (add)
                        {$c_i \leftarrow c_i + a_i \cdot b_{k-i}$};
                \node[block, above of=loop1, node distance=2.5em,
                        xshift=-10em] (inc1) {$j \leftarrow j + 1$};
                \node[draw, ellipse, below of=loop0, xshift=-6em]
                        (end) {End};

                \draw[->] (begin) -- (init0);
                \draw[->] (init0) -- (loop0);
                \draw[->] (loop0) -| node{Да} (init11);
                \draw[->] (init11) -- (init12);
                \draw[->] (init12) -- (loop1);
                \draw[->] (loop1) -- node{Да} (doadd);
                \draw[->] (doadd) -| node{Да} (add);
                \draw[->] (doadd) -| node[near start]{Нет} (inc1);
                \draw[->] (add) -| (inc1);
                \draw[->] (loop1) -| node[near start]{Нет} (inc0);
                \draw[->] (inc0) -| (loop0);
                \draw[->] (inc1) -| (loop1);
                \draw[->] (loop0) -| node[above left, near start]{Нет} (end);
        \end{tikzpicture}
        \caption{Блок-схема алгоритма}
\end{figure}

# Выполнение

## Числа с плавающей точкой

\begin{scriptsize}
\verbatiminput{src/fold_f32.rs}
\end{scriptsize}

## Числа с ограниченной разрядностью

\begin{scriptsize}
\verbatiminput{src/fold.rs}
\end{scriptsize}

## Графики зависимостей

Для заданного ядра оказалось, что при любой длине вектора заданной точности
оказывается достаточно. Действительно, положительная и отрицательная компоненты
суммы имеют максимальную разрядность $8 + 3 = 11$ битов. Соответственно, сумма
компонент не может превышать $11$ битов ни в нижнюю, ни в верхнюю сторону, и
один бит отводится на знак.

Погрешность наблюдается лишь при ограничении разрядности входных данных
(максимальное СКО --- 2) и при ограничении разрядности ядра до двух битов, что
приводит к преобразованию ядра в [0, 0, 4, 0, 0] и, соответственно, к
существенным отклонениям (СКО порядка сотен).

С другой стороны, для ядра [8, 8, 8, 8, 8] картина совсем иная. Действительно,
перемножая числа с разрядностями 8 и 4 бита, имеем число разрядностью 12 битов.
Складывая пять таких чисел, получаем число разрядностью в 16 битов.

Для этого ядра также обнаружено, что округление и обрезание нижних битов не
приводят к потере точности, в отличие от обрезания и увеличения верхних битов
на единицу.

Также по графикам можно установить, что имеется зависимость не от размера
входного вектора, но от отношения длины строба ко всей длине вектора. Это
отношение в рамках опыта менялось периодически.

\begin{figure}[h!]
        \centering
        \includegraphics[page=1]{stdev_u.pdf}
        \caption{Зависимость СКО от длины входного вектора для разных видов
        фильтрации с ядром [-1, -1, 4, -1, -1]}
\end{figure}

\begin{figure}[h!]
        \centering
        \includegraphics[page=1]{stdev_f.pdf}
        \caption{Зависимость СКО от длины входного вектора для разных видов
        фильтрации с ядром [8, 8, 8, 8, 8]}
\end{figure}

# Вывод

В результате выполнения работы было выяснено, что длина входного вектора не
оказывает существенного влияния на погрешность апериодической свёртки,
ограниченной по разрядности. С другой стороны, разрядность ядра очень важна.

\begin{thebibliography}{9}
\bibitem{thebook}
Рабинер Л., Гоулд Б.
\textit{Теория и применение цифровой обработки сигналов.}.
М: Мир, 1978.

\bibitem{theref}
Матвеев Ю.Н., Симончик К.К., Тропченко А.Ю., Хитров М.В.
\textit{Цифровая обработка сигналов}.
Университет ИТМО, 2013

\bibitem{wiki}
Свёртка последовательностей -- Википедия.

\texttt{https://ru.wikipedia.org/wiki/Свертка\_последовательностей}

\bibitem{stud}
Апериодическая свертка и корреляция -- Студопедия.

\texttt{https://studopedia.ru/8\_192842\_aperiodicheskaya-svertka-i-korrelyatsiya.html}

\end{thebibliography}
